# 第 6 章 通用的模块是更深的

> Chapter 6 General-Purpose Modules are Deeper

> The process of teaching my software design course, in which I’m constantly trying to identify the causes of complexity in student code, has changed my thinking about software design in several ways. The most important of these has to do with generality versus specialization. I have found over and over that specialization leads to complexity; I now think that over-specialization may be the single greatest cause of complexity in software. Conversely, code that is more general-purpose is simpler, cleaner, and easier to understand.

在我教授软件设计课程的过程中，我一直试图找出学生代码中复杂性的原因。在这个过程中，我对软件设计的思考方式已经发生了几次变化。其中最重要的想法关于通用化还是专用化。我不断地发现，专用化会导致复杂性；我现在认为，过于专用化可能是软件中最大的复杂性来源。相反，通用的代码更简单、更干净，也更容易理解。

> This principle applies at many different levels in software design. When designing modules such as classes or methods, one of the best ways to produce a deep API is to make it general-purpose (general-purpose APIs result in more information hiding). When writing detailed code, one of the most effective ways to simplify the code is by eliminating special cases, so that the common-case code handles the edge cases as well. Eliminating special cases can also make code more efficient, as we shall see in Chapter 20.

这个原则在软件设计的不同层级上都适用。在设计类或方法等模块时，产生一个深 API 的最佳方法是使其通用化（通用 API 能更好地进行信息隐藏）。在编写详细代码时，消除特殊情况是简化代码的最有效方法，这样通用代码也能处理边界情况。消除特殊情况还可以使代码更高效，正如我们在将在[第 20 章](ch20.md)中看到的。

> This chapter discusses the problems caused by specialization and the benefits of generality. Specialization cannot be completely eliminated, so the chapter also offers guidelines on how to separate special-purpose code from general-purpose code.

这个章节讨论了专用化带来的问题以及通用化的好处。因为专用化不能完全消除，本章还提供了关于如何将专用代码与通用代码分离开来的指南。

## 6.1 使类的接口足够通用

> 6.1 Make classes somewhat general-purpose

> One of the most common decisions that you will face when designing a new class is whether to implement it in a general-purpose or special-purpose fashion. Some might argue that you should take a general-purpose approach, in which you implement a mechanism that can be used to address a broad range of problems, not just the ones that are important today. In this case, the new mechanism may find unanticipated uses in the future, thereby saving time. The general-purpose approach seems consistent with the investment mindset discussed in Chapter 3, where you spend a bit more time up front to save time later on.

设计新的类时，您将面临的最常见的决定之一就是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方式，在这种方式中，您将实现一种可用于解决广泛问题的机制，而不仅是当前重要的问题。在这种情况下，该机制可能会在将来发现意外用途，从而节省时间。通用方式似乎与[第 3 章](ch03.md)中讨论的投资思维一致，您花了更多时间在前面，以节省以后的时间。

> On the other hand, we know that it’s hard to predict the future needs of a software system, so a general-purpose solution might include facilities that are never actually needed. Furthermore, if you implement something that is too general-purpose, it might not do a good job of solving the particular problem you have today. As a result, some might argue that it’s better to focus on today’s needs, building just what you know you need, and specializing it for the way you plan to use it today. If you take the special-purpose approach and discover additional uses later, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.

另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用专用的方式并在以后发现要支持更多用途，您总是可以对其进行重构以使其通用。专用方式似乎与软件开发的增量方式一致。

> When I first started teaching my software design course I leaned towards the second approach (make it special-purpose to begin with), but after teaching the course a few times I changed my mind. In reviewing student projects I noticed that general-purpose classes were almost always better than special-purpose alternatives. What particularly surprised me is that general-purpose interfaces are simpler and deeper than special-purpose ones, and they result in less code in the implementation. It turns out that even if you use a class in a special-purpose way, it’s less work to build it in a general-purpose way. And, the general-purpose approach can save you even more time in the future, if you reuse the class for other purposes. But general-purpose is still better even if you don’t reuse the class.

当我开始教授我的软件设计课程时，我倾向于第二种方法（首先使其专用），但经过几次课程教授后，我改变了主意。在评审学生项目时，我注意到通用类几乎总是优于专用类。令我惊讶的是，通用接口比专用接口更简单和更深，它们还可以减少实现的代码量。事实证明，即使您以专用方式使用某个类，以通用方式下构建这个类也更容易。而且，通用方法在您将该类重用于其他目的时可以为您节省更多未来的时间。但是，即使您不重用该类，通用方法仍然更好。

> In my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.

以我的经验，最有效的办法是以有点通用的方式实现新模块。这里的短语“有点通用”表示该模块的功能应反映您当前的需求，但其接口则不应该。相反，该接口应该足够通用以支持多种用途。该接口应易于使用，以满足当今的需求，而不必专门与它们绑在一起。“有点”这个词很重要：不要忘乎所以，建立一些太过通用的东西，以至于很难满足你当前的需求。

## 6.2 示例：为编辑器存储文本

> 6.2 Example: storing text for an editor

> Let’s consider an example from a software design class in which students were asked to build a simple GUI text editor. The editor had to display a file and allow users to point, click, and type to edit the file. It also had to support multiple simultaneous views of the same file in different windows, and it had to support multi-level undo and redo for modifications to the file.

让我们考虑一个软件设计课程的示例，其中要求学生构建一个简单的图形界面文本编辑器。该编辑器必须能显示一个文件，并允许用户指向、点击并输入以编辑该文件。编辑器必须支持同一文件在不同窗口中的多个并行视图，它还必须支持文件修改的多级撤销和重做。

> Each of the student projects included a class that managed the underlying text of the file. The text classes typically provided methods for loading a file into memory, reading and modifying the text of the file, and writing the modified text back to a file.

每个学生项目都包括一个管理文件内的文本的类。文本类通常提供以下方法：将文件加载到内存、读取和修改文件的文本以及将修改后的文本写回到文件。

> Many of the student teams implemented special-purpose APIs for the text class. They knew that the class was going to be used in an interactive editor, so they thought about the features that the editor had to provide and tailored the API of the text class to those specific features. For example, if a user of the editor typed the backspace key, the editor deleted the character immediately to the left of the cursor; if the user typed the delete key, the editor deleted the character immediately to the right of the cursor. Knowing this, some of the teams created one method in the text class to support each of these specific features:

许多学生团队为文本类实现了专用的 API。他们知道该类将在交互式编辑器中使用，因此他们考虑了编辑器必须提供的功能，并针对这些特定功能定制了文本类的 API。例如，如果编辑器的用户输入了退格键，则编辑器会立即删除光标左侧的字符；如果用户键入了删除键，则编辑器会立即删除光标右侧的字符。知道这一点后，一些团队在文本类中针对每个特定功能都创建了一个方法：

```java
void backspace(Cursor cursor);

void delete(Cursor cursor);
```

> Each of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:

这些方法中的每一个都以光标位置作为参数，并用专用的类型 Cursor 来表示。编辑器还必须支持复制或删除一个选择的区域。学生通过定义 Selection 类并在删除过程中将该类的对象传递给文本类来解决此问题：

```java
void deleteSelection(Selection selection);
```

> The students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users. In reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class. The text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation. Many of the methods, such as delete, were only invoked in a single place. As a result, a developer working on the user interface had to learn about a large number of methods for the text class.

学生们可能认为，如果文本类的方法与用户可见的功能相对应，则将更易于实现用户界面。但是，实际上，这种专业化对用户界面代码几乎没有好处，并且为用户界面或文本类的开发人员带来了很高的认知负荷。文本类最终包含了大量的浅方法，每个浅方法仅适用于一个用户界面操作。许多方法（例如 delete）仅在单个位置被调用。结果，用户界面的开发人员必须学习文本类的大量方法。

> This approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well. One of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.

这种方式在用户界面和文本类之间造成了信息泄露。与用户界面有关的抽象（例如区域选择或退格键）反映在文本类中；这增加了文本类的开发人员的认知负荷。每个新的用户界面操作都需要在文本类中定义一个新方法，因此该用户界面的开发人员最终可能也要处理这个文本类。类设计的目标之一是允许每个类独立开发，但是专用方式将用户界面和文本类绑定在了一起。

## 6.3 更通用的 API

> 6.3 A more general-purpose API

> A better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text:

更好的方法是使文本类更通用。其 API 应仅根据基本的文本功能进行定义，而不应反映用其实现的更高层级的操作。例如，只需提供两个方法即可修改文本：

```java
void insert(Position position, String newText);

void delete(Position start, Position end);
```

> The first method inserts an arbitrary string at an arbitrary position within the text, and the second method deletes all of the characters at positions greater than or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions within the text, such as the following:

前一个方法在文本内的任意位置插入任意字符串，后一个方法删除大于或等于开始位置但小于结束位置的所有字符。此 API 还使用了更通用的 Position 类型来代替 Cursor，后者则是特别针对用户界面的。文本类还应该提供用于操纵文本中位置的通用方法，例如：

```java
Position changePosition(Position position, int numChars);
```

> This method returns a new position that is a given number of characters away from a given position. If the numChars argument is positive, the new position is later in the file than position; if numChars is negative, the new position is before position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the following code (assuming the cursor variable holds the current cursor position):

此方法返回一个新位置，该位置与给定位置相距给定的字符数。如果 numChars 参数为正，则新位置在文件中给定位置的后面；如果 numChars 为负，则新位置在给定位置之前。必要时，该方法会自动跳到下一行或上一行。使用这些方法，可以使用以下代码来实现删除键（假定 cursor 变量保存了当前光标的位置）：

```java
text.delete(cursor, text.changePosition(cursor, 1));
```

> Similarly, the backspace key can be implemented as follows:

类似的，可以按以下方式实现退格键：

```java
text.delete(text.changePosition(cursor, -1), cursor);
```

> With the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API. However, the new code is more obvious than the old code. A developer working in the user interface module probably cares about which characters are deleted by the backspace key. With the new code, this is obvious. With the old code, the developer had to go to the text class and read the documentation and/or code of the backspace method to verify the behavior. Furthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.

使用通用文本 API，实现用户界面功能（如删除和退格）的代码比使用专用文本 API 的原始方法要长一些。但是，新代码比旧代码更易理解。用户界面模块的开发人员可能会关心退格键会删除哪些字符。使用新代码，这是显而易见的。使用旧代码，开发人员必须去文本类中阅读退格方法的文档或代码以验证该行为。此外，通用方法总体上比专用方法具有更少的代码，因为它用较少数量的通用方法代替了文本类中的大量专用方法。

> A text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor. As one example, suppose you were building an application that modified a specified file by replacing all occurrences of a particular string with another string. Methods from the specialized text class, such as backspace and delete, would have little value for this application. However, the general-purpose text class would already have most of the functionality needed for the new application. All that is missing is a method to search for the next occurrence of a given string, such as this:

使用通用接口实现的文本类除交互式编辑器外，还可以用于其他目的。作为一个示例，假设您正在构建一个应用程序，该应用程序通过将所有出现的特定字符串替换为另一个字符串来修改指定文件。专用文本类中的方法（例如 backspace 和 delete）对于此应用程序几乎没有价值。但是，通用文本类已经具有新应用程序所需的大多数功能。缺少的只是一个搜索给定字符串的下一个匹配项的方法，例如：

```java
Position findNext(Position start, String string);
```

> Of course, an interactive text editor is likely to have a mechanism for searching and replacing, in which case the text class would already include this method.

当然，交互式文本编辑器可能具有搜索和替换的机制，在这种情况下，文本类将已经包含此方法。

## 6.4 通用性可以更好地隐藏信息

> 6.4 Generality leads to better information hiding

> The general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding. The text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functions in the text class. The general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.

通用方法在文本类和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。在添加新的用户界面功能时，也无需在文本类中创建新的支持方法。通用接口还减轻了认知负荷：用户界面的开发人员只需要学习几个简单的方法，就可以将其复用于各种目的。

> The backspace method in the original version of the text class was a false abstraction. It purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior. Putting the method in the text class just makes it harder for user interface developers to get the information they need. One of the most important elements of software design is determining who needs to know what, and when. When the details are important, it is better to make them explicit and as obvious as possible, such as the revised implementation of the backspace operation. Hiding this information behind an interface just creates obscurity.

文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会需要阅读 backspace 方法的代码以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时需要知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的退格键操作实现。将这些信息隐藏在接口后面只会产生模糊性。

## 6.5 问自己一些问题

> 6.5 Questions to ask yourself

> It is easier to recognize a clean general-purpose class design than it is to create one. Here are some questions you can ask yourself, which will help you to find the right balance between general-purpose and special-purpose for an interface.

识别干净的通用类设计要比创建它更简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。

> **What is the simplest interface that will cover all my current needs?** If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things.

**满足我当前所有需求的最简单的接口是什么？** 如果能减少 API 中的方法数量而不降低其整体功能，那您可能正在创建更通用的方法。专用的文本 API 至少具有三个删除文本的方法：backspace、delete 和 deleteSelection。而更通用的 API 只有一个删除文本的方法，它可以同时满足所有三个目的。仅在每个方法的 API 都保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多额外的参数以减少方法数量，那么您可能并没有真正简化事情。

> **In how many situations will this method be used?** If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method.

**这个方法会在多少种情况下被使用？** 如果一个方法是为特定用途而设计的，例如 backspace 方法，那就是一个表明它可能过于专用的危险信号。看看是否可以用一个通用方法替换几个专用方法。

> **Is this API easy to use for my current needs?** This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.

**这个 API 对于我当前的需求来说是否易于使用？** 这个问题可以帮助确定当你在让一个 API 变得简单和通用时是否走得太远了。如果您必须编写许多其他代码才能将类用于当前的用途，那么这是一个接口没有提供正确功能的危险信号。例如，针对文本类的一种方式是围绕单字符操作进行设计：用于插入单个字符的 insert 方法和 用于删除单个字符的 delete 方法。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高层级的代码将包含许多用于插入或删除字符范围的循环。单字符方法对于大型操作也将是低效的。因此，文本类最好内置对字符范围操作的支持。

## 6.6 将专用代码上移（或下移！）

> 6.6 Push specialization upwards (and downwards!)

> Most software systems must inevitably have some code that is specialized. For example, applications provide specific features for their users; these are often highly specialized. Thus it isn’t usually possible to eliminate specialization altogether. However, specialized code should be cleanly separated from general-purpose code. This can be done by pushing the specialized code either up or down in the software stack.

大部分软件系统不可避免地必须有一些专用的代码。例如，应用程序为用户提供了特定的功能，这些功能通常非常专用化。因此，通常不可能完全消除专用的代码。然而，专用的代码应该与通用的代码清晰地分离，这可以通过将专用代码在软件栈中上移或下移来实现。

> One way to separate specialized code is to push it upwards. The top-level classes of an application, which provide specific features, will necessarily be specialized for those features. But this specialization need not percolate down into the lower-level classes that are used to implement the features. We saw this in the editor example earlier in this chapter. The original student implementation leaked specialized user-interface details such as the behavior of the backspace key down into the implementation of the text class. The improved text API pushed all of the specialization upwards into the user interface code, leaving only general-purpose code in the text class.

一种分离专用代码的方式是将其往上移。应用程度的顶层类因为要提供特定的功能特性，所以只能是专用于这些特性的。但这种专用代码不需要渗透到实现这些特性的较底层类中。我们在前面的编辑器例子中已经看到过这种情况。学生的原始实现将专用的用户界面细节（比如退格键的行为）泄露到了文本类的实现中。改进后的文本 API 将所有的专用代码上移到了用户界面代码，文本类中只留下了通用的代码。

> Sometimes the best approach is to push specialization downwards. One example of this is device drivers. An operating system typically must support hundreds or thousands of different device types of devices, such as different kinds of secondary storage devices. Each of these device types has its own specialized command set. In order to prevent specialized device characteristics from leaking into the main operating system code, operating systems define an interface with general-purpose operations that any secondary storage device must implement, such as “read a block” and “write a block”. For each different device, a device driver module implements the general-purpose interface using the specialized features of that particular device. This approach pushes specialization down into the device drivers, so that the core of the operating system can be written without any knowledge of specific device characteristics. This approach also makes it easy to add new devices: if a device has enough features to implement the device driver interface, it can be added to the system with no changes to the main operating system.

有时分离专用代码的最好方式是将其往下移。一个例子是设备驱动程序。操作系统通常必须支持数百或数千种不同类型的设备，例如不同类型的辅助存储设备。每种类型的设备都有自己的专用命令集。为了防止专用的设备特征泄露到主操作系统代码中，操作系统定义了任何辅助存储设备都必须实现的通用操作的接口，例如“读取块”和“写入块”。对于每种不同的设备，设备驱动程序模块使用该特定设备的专用功能来实现了这些通用接口。这种方式将专用代码下移到设备驱动程序，因此在写操作系统的核心代码时不需要了解任何特定的设备特征。这种方式使得可以轻松地添加新设备：只要设备完整地实现了设备驱动程序接口，就可以在不需要对主操作系统代码做任何修改的情况下添加到系统中。

## 6.7 示例：编辑器撤销机制

> 6.7 Example: editor undo mechanism

> In the GUI editor project, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view. For example, if a user selects some text, deletes it, scrolls to a different place in the file, and then invokes undo, the editor must restore its state to what it was just before the deletion. This includes restoring the deleted text, selecting it again, and also making the selected text visible in the window.

在图像界面编辑器项目中，要求之一是支持多级的撤消/重做，不仅是文本的改动，还有区域选择、插入光标、和视图的改动。例如，如果用户选择了一些文本，将其删除，滚动到文件中的其他位置，然后使用撤消操作，则编辑器必须将其状态恢复为删除前的状态。这包括还原已删除的文本、再次选择它、并使所选的文本在窗口中可见。

> Some of the student projects implemented the entire undo mechanism as part of the text class. The text class maintained a list of all the undoable changes. It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list. When undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list. For entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.

一些学生项目将整个撤消机制实现为文本类的一部分。文本类维护所有可撤消更改的列表。每次更改文本时，它都会自动将条目添加到此列表中。对于区域选择、插入光标和视图的更改，用户界面代码将调用文本类中的相应方法，以将这些更改的条目添加到撤消列表中。当用户请求撤消或重做时，用户界面代码将调用文本类中的方法，然后该方法处理撤消列表中的条目。对于与文本相关的条目，它直接更新文本类的内部状态。对于与其他事物（例如区域选择）相关的条目，文本类反过来调用用户界面代码来执行撤销或重做。

> This approach resulted in an awkward set of features in the text class. The core of undo/redo consists of a general-purpose mechanism for managing a list of actions that have been executed and stepping through them during undo and redo operations. The core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection. The special-purpose undo handlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth. If a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition, the general-purpose undo core had little to do with the general-purpose text facilities in the class.

这种方法导致了文本类中的一系列尴尬特性。撤消/重做的核心功能由通用机制组成，用于管理已执行的动作列表，并在撤消和重做操作期间逐个执行这些动作。核心功能与对诸如文本和区域选择实现了撤消和重做的专用处理程序一起位于文本类中。用于区域选择和插入光标的专用撤消处理程序与文本类中的任何其他内容均无关。它们导致了文本类和用户界面之间的信息泄漏，以及每个模块中来回传递撤消信息的额外方法。如果未来将新的可撤消实体添加到系统中，则将需要更改文本类，包括特定于该实体的新方法。此外，通用的撤销核心功能与文本类中的通用文本功能也几乎没有关系。

> These problems can be solved by extracting the general-purpose core of the undo/redo mechanism and placing it in a separate class:

通过提取撤消/重做机制的通用核心功能并将其放在单独的类中，可以解决这些问题：

```java
public class History {
    public interface Action {
        public void redo();
        public void undo();
    }

    History() {...}

    void addAction(Action action) {...}
    void addFence() {...}
    void undo() {...}
    void redo() {...}
}
```

> In this design, the History class manages a collection of objects that implement the interface History.Action. Each History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation. The History class knows nothing about the information stored in the actions or how they implement their undo and redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.

在此设计中，History 类用来管理实现了接口 History.Action 的对象的集合。每个 History.Action 描述一个操作，例如插入文本或更改光标位置，并且它提供了可以撤消或重做该操作的方法。History 类对操作中存储的信息或它们如何实现其撤消和重做方法一无所知。History 类维护一个历史记录列表，该列表描述了应用程序生命周期内执行的所有操作，它还提供了撤消和重做方法，这些方法响应用户请求的撤消和重做，在 History.Actions 中调用撤消和重做方法。

> History.Actions are special-purpose objects: each one understands a particular kind of undoable operation. They are implemented outside the History class, in modules that understand particular kinds of undoable actions. The text class might implement UndoableInsert and UndoableDelete objects to describe text insertions and deletions. Whenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list. The editor’s user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selection and insertion cursor.

History.Actions 都是专用的对象：每个对象都了解一种特殊的可撤销操作。它们在 History 类之外的模块中实现，这些模块可以理解特定类型的可撤销操作。文本类可能实现 UndoableInsert 和 UndoableDelete 对象，以描述文本的插入和删除。每当插入文本时，文本类都会创建一个描述该插入操作的新 UndoableInsert 对象，并调用 History.addAction 将其添加到历史列表中。编辑器的用户界面代码可能会创建 UndoableSelection 和 UndoableCursor 对象，这些对象描述对选择和插入光标的更改。

> The History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor. To implement grouping the History class uses fences, which are markers placed in the history list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence. The placement of fences is determined by higher-level code by invoking History.addFence.

History 类还允许对操作进行分组，例如，来自用户的单个撤消请求可以恢复已删除的文本、重新选择已删除的文本以及重新放置插入光标。History 类使用了栅栏来对操作进行分组，栅栏是放置在历史列表中的标记，用于分隔相关操作的组。每次对 History.redo 的调用都会向后遍历历史记录列表，撤消操作，直到到达下一个栅栏。栅栏的位置由更高层级的代码通过调用 History.addFence 来决定。

> This approach divides the functionality of undo into three categories, each of which is implemented in a different place:

这种方法将撤消操作的功能分为三个类别，每个类别都在不同的地方实现：

> - A general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).
> - The specifics of particular actions (implemented by a variety of classes, each of which understands a small number of action types).
> - The policy for grouping actions (implemented by high-level user interface code to provide the right overall application behavior).

- 一个用于管理和分组操作以及调用撤消和重做操作的通用机制（由 History 类实现）。
- 特定操作的细节（由多个类实现，每个类都理解少量的操作类型）。
- 分组操作的策略（由高层级用户界面代码实现，以提供正确的整体应用程序行为）。

> Each of these categories can be implemented without any understanding of the other categories. The History class does not know what kind of actions are being undone; it could be used in a variety of applications. Each action class understands only a single kind of action, and neither the History class nor the action classes needs to be aware of the policy for grouping actions.

这些类别中的每一个都可以在不了解其他类别的情况下被实现。History 类不知道要撤消哪种操作；它可以在多种应用中被使用。每个操作类仅理解一种操作，并且 History 类和操作类都不需要知道将操作分组的策略。

> The key design decision was the one that separated the general-purpose part of the undo mechanism from the special-purpose parts, creating a separate class for the general-purpose part and pushing the special-purpose parts down into subclasses of History.Action. Once that was done, the rest of the design fell out naturally.

关键的设计决策是将撤消机制的通用部分与专用部分分开，为通用部分创建单独的类并将专用的部分下沉到 `History.Action` 的子类中。一旦完成，其余的设计就自然而然的出现了。

> Note: the suggestion to separate general-purpose code from special-purpose code refers to code related to a particular mechanism. For example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list). However, it may make sense to combine special-purpose code for one mechanism with general-purpose code for another. The text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special-purpose because it only handles undo operations for text modifications. It doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.

注意：将通用代码与专用代码分开的建议是指与特定机制相关的代码。例如，特殊用途的撤消代码（例如撤消文本插入的代码）应该与通用用途的撤消代码（例如管理历史记录列表的代码）分开。然而，将一种机制的专用代码与另一种机制的通用代码组合起来可能也是有意义的。文本类就是这样一个例子：它实现了一种管理文本的通用机制，但是它包含了与撤销相关的专用代码。这些撤消代码是专用的，因为它只处理文本修改的撤消操作。将这段代码与 History 类中通用的撤销代码组合在一起没有意义，但是将它放在文本类中是有意义的，因为它与其他文本函数密切相关。

## 6.8 消除代码里的特殊情况

> 6.8 Eliminate special cases in code

> Up until this point I have been discussing specialization in the context of class and method design. Another form of specialization occurs in the code for method bodies, in the form of special cases. Special cases can result in code that is riddled with if statements, which make the code hard to understand and are prone to bugs. Thus, special cases should be eliminated wherever possible. The best way to do this is by designing the normal case in a way that automatically handles the edge conditions without any extra code.

到目前为止的讨论都是针对类和方法设计里的专用化。另一种形式的专用化发生在方法的实现体里，以特殊情况的形态出现。特殊情况会导致代码中充斥着 `if` 语句，这使代码难以理解并容易导致缺陷。因此，应尽可能地消除特殊情况。做到这一点的最好方法是以一种无需任何额外代码就能自动处理边界情况的方式来设计正常情况。

> In the text editor project, students had to implement a mechanism for selecting text and copying or deleting the selection. Most students introduced a state variable in their selection implementation to indicate whether or not the selection exists. They probably chose this approach because there are times when no selection is visible on the screen, so it seemed natural to represent this notion in the implementation. However, this approach resulted in numerous checks to detect the “no selection” condition and handle it specially.

在文本编辑器项目中，学生必须实现一种选择文本以及复制或删除所选内容的机制。大多数学生在他们的选择实现中引入了状态变量，以表明选择是否存在。他们之所以使用这种方法，是因为有时屏幕上看不到任何选择，因此在实现中似乎很自然地代表了这一概念。但是，这种方法导致了大量的检查，以检测“没有选择”的情况，并专门处理它。

> The selection handling code can be simplified by eliminating the “no selection” special case, so that the selection always exists. When there is no selection visible on the screen, it can be represented internally with an empty selection, whose starting and ending positions are the same. With this approach, the selection management code can be written without any checks for “no selection”. When copying the selection, if the selection is empty then 0 bytes will be inserted at the new location; if implemented correctly, there will be no need to check for 0 bytes as a special case. Similarly, it should be possible to design the code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection, extract the portion of the line preceding the selection and concatenate it with the portion of the line following the selection to form the new line. If the selection is empty, this approach will regenerate the original line.

通过消除“没有选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，管理选择的代码无需对“没有选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节。如果正确实现，无需将 0 字节作为特殊情况来处理。同样，对于删除选择的代码，应该也能设计成无需任何对特殊情况的检查就可以处理选择为空的情况。考虑选择一整行的情况。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。

> Chapter 10 will discuss exceptions, which create many more special cases, and how to reduce the number of places where they must be handled.

[第 10 章](ch10.md)将讨论异常（它们导致了更多的特殊情况）以及如何减少必须处理异常的地方的数量。

## 6.9 结论

> 6.9 Conclusion

> Unnecessary specialization, whether in the form of special-purpose classes and methods or special cases in code, is a significant contributor to software complexity. Specialization can’t be eliminated completely, but with good design you should be able to reduce it significantly and separate specialized code from general-purpose code. This will result in deeper classes, better information hiding, and simpler and more obvious code.

不必要的专用代码，不管是专用的类或方法还是代码里的特殊情况，都是软件复杂性的主要来源。专用代码无法完全消除，但通过好的设计您应该能够显著减少专用代码，并将专用代码与通用代码分开。这将导致更深的类、更好的信息隐藏以及更简单和更显而易见的代码。 